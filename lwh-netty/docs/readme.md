# netty

## 1、到底什么时候用输入流，什么时候用输出流？

关于输入流和输出流的使用我一直都很迷惑。到底什么时候用输入流什么时候用输出流这里举个栗子给大家看看就能很容易的记住并理解了

打比方说两个聊天程序A和B进行对话。底层通过IO流来实现的。

第一步： A向B发送一个消息。那么A会创建一个输出流，将数据写入到输出流里面然后发送出去。
第二步： B收到了A发送过来的数据，其实就是IO流。这时候对于B来说这个IO流就是输入流了。因为是从A发送过来的流，所以就是输入流。当B需要得到输入流中的数据的时候就需要读出输入流中的数据。这也就是另一个迷惑人的地方。

**输入流要被读，而输出流要往里写。这一点一定要记住。**

总结：
**数据写入到输入流 ， 然后发送 , 然后，另一个端获取到的流是输出流。就要读出**

## 什么是IO多路复用，理解IO多路复用

BIO: 一个线程只能处理一个套接字的I/O事件

正因为阻塞I/O只能阻塞一个I/O操作，而I/O复用模型能够阻塞多个I/O操作，所以才叫做多路复用。

NIO：在同一个线程里面， 通过拨开关的方式，来同时传输多个I/O流， (学过EE的人现在可以站出来义正严辞说这个叫“时分复用”了）。

举例说明：

下面举一个例子，模拟一个tcp服务器处理30个客户socket。假设你是一个老师，让30个学生解答一道题目，然后检查学生做
的是否正确，你有下面几个选择：

1. 第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。
这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。

2. 第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。

3. 第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后
继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 这种就是IO复用模型，Linux下的select、poll和epoll就是干
这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。
此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息
是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。

**I/O多路复用(又被称为“事件驱动”)**